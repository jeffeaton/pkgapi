##' @title Basic endpoint object
##'
##' @description Create a \code{pkgapi_endpoint} object that collects
##'   together an HTTP method (e.g., \code{GET}), a path (e.g.,
##'   \code{/path}) and a target R function.  Unlike plumber
##'   endpoints, pkgapi endpoints are meant to be used in testing.
##'
##' @export
pkgapi_endpoint <- R6::R6Class(
  "pkgapi_endpoint",
  cloneable = FALSE,

  private = list(
    process = NULL,
    validate_response = NULL
  ),

  public = list(
    ##' @field method HTTP method
    method = NULL,
    ##' @field path HTTP path
    path = NULL,
    ##' @field target R function used for the endpoint
    target = NULL,
    ##' @field validate Logical, indicating if response validation is used
    validate = NULL,
    ##' @field inputs Input control
    inputs = NULL,
    ##' @field returning An \code{\link{pkgapi_returning}} object
    ##' controlling the return type (content type, status code,
    ##' serialisation and validation information).
    returning = NULL,

    ##' @description Create an endpoint
    ##'
    ##' @param method The HTTP method to support
    ##'
    ##' @param path The server path for the endpoint
    ##'
    ##' @param target An R function to run as the endpoint
    ##'
    ##' @param returning Information about what the endpoint returns,
    ##    as created by \code{\link{pkgapi_returning}}
    ##'
    ##' @param validate Logical, indicating if any validation
    ##' (implemented by the \code{validate_response} argument) should be
    ##' enabled.  This should be set to \code{FALSE} in production
    ##' environments.
    ##'
    ##' @param input_query Information on input parameters, using
    ##' \code{\link{pkgapi_input_query}}.  The names used must match
    ##' the names in \code{target}.
    ##'
    ##' @param input_body Information on body, using
    ##' \code{\link{pkgapi_input_body_binary}} or
    ##' \code{\link{pkgapi_input_body_json}}.  Only a single body
    ##' element can be specified.
    ##'
    ##' @param validate_response Optional function that throws an error
    ##' of the processed body is "invalid".
    initialize = function(method, path, target, ..., returning,
                          validate = FALSE) {
      self$method <- method
      self$path <- path
      self$target <- target
      assert_is(returning, "pkgapi_returning")
      self$returning <- returning

      other <- list(...)
      done <- logical(length(other))

      input_classes <- c("pkgapi_input", "pkgapi_input_collection")
      is_input <- vlapply(other, inherits, input_classes)
      self$inputs <- pkgapi_inputs$new(
        c(pkgapi_input_path(path), other[is_input]))$bind(target)
      done[is_input] <- TRUE

      if (any(!done)) {
        ## NOTE: this is really hard to get a great error message out
        ## of, as these arguments could be anywhere.  httr does not do
        ## a much better job (httr::GET("https://example.com", 1)) but
        ## it would be nice to be able to guide the user here.
        err <- other[!done]
        nms <- names(err) %||% rep("", length(err))
        nms[!nzchar(nms)] <- "unnamed argument"
        cl <- vcapply(err, function(x) paste(class(x), collapse = "/"))
        stop("Unconsumed dot arguments: ",
             paste(sprintf("%s (%s)", cl, nms), collapse = ", "),
             call. = FALSE)
      }

      self$validate <- validate
      lock_bindings(c("method", "path", "target", "inputs", "returning"),
                    self)
    },

    ##' @description Run the endpoint.  This will produce a
    ##' standardised response object that contains \code{status_code},
    ##' \code{content_type}, \code{body} (the serialised output as run
    ##' through the \code{process} method and returned by plumber) and
    ##' \code{data} (the result of running the target function)
    ##'
    ##' @param ... Arguments passed through to the \code{target} function
    run = function(...) {
      tryCatch({
        data <- self$target(...)
        body <- self$returning$process(data)
        if (self$validate) {
          self$returning$validate(body)
        }
        pkgapi_response(self$returning$status_code,
                        self$returning$content_type, body, data = data)
      }, error = pkgapi_process_error)
    },

    ##' @description Helper method for use with plumber - not designed
    ##' for end-user use.  This is what gets called by plumber when the
    ##' endpoint recieves a request.
    ##'
    ##' @param req,res Conventional plumber request/response objects
    ##' @param ... Additional arguments passed through to \code{run}
    plumber = function(req, res, ...) {
      ## It's not abundantly clear here what we do to get the path
      ## args, and they cannot be retrieved from the filters it seems.
      tryCatch({
        given <- list(
          path = req$args[seq_len(length(req$args) - 2L)],
          query = req$pkgapi_query,
          body = req$pkgapi_body)
        args <- self$inputs$validate(given)
        do.call(self$run, args)
      }, error = pkgapi_process_error)
    }
  ))
